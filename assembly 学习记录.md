# assembly 学习记录

    1.机器语言
    2.编译器
    3.汇编语言
        汇编语言是机器语言的封装，有更好的助记符





# 基础
    1.2 汇编的产生
        程序员 ---- 汇编指令 ----- 编译器 ----- 机器码 ---- CPU
        CPU ----- 内存 ----- 外存 
        RAM ROM
    1.6 储存单元
        1byte = 8bit
        10的6次方 = 64
            7次方 = 128
            8次方 = 256
            10次方 = 1024
            16次方 = 65535
    1.7 CPU对储存器的读写  也就是对内存的的操作
            储存单元的地址（地址信息）
            器件的选择，读取或写入的命令 (控制信息)
            读或写的数据（数据信息）
    1.8 地址总线
            1.CPU是通过地址总线来指定储存器单元的。地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址
            2.
    思考:
        为什么一个段最大为 64kb  
            因为8086的数据总线是，16位，但是它的地址总线为20位，正常来说，16位的限制使得寻址只能是2的16次方，
            也就是64kb，相对于1mb差了很多，我们想用更大的寻址空间。所以引入了段地址与偏移地址的概念，
            通过地址加法运算器，使得1mb寻址成为现实，1mb的寻址意味着更大的内存空间。
            要理解这个，必须要知道16进制，2进制，1mb寻址空间有16个64kb的段   
            16进制 
                    1 2 3 4 5 6 7 8 9 A B C D E F   16进1
            16X64 =1024 意味着 0000-0FFF 1000-1FFF A000-AFFF F000-FFF0 一个有16个段，每个段64kb
            0000 段大小 = 0FFF-OOOO = FFF x 16 = 65520  乘以16是为了得到十进制的65520 
            一个段，在没进入运算器之前是16位的，所以他只能是64kb，

        为什么最大寻址空间为 1mb
# 2023.12.29 学习记录" 基础
    
    1.控制指令 
        mov add
        指令例
            #        a         b
            # ax = 00000000  00000000
            # a  = ah  是高八位
            # b  = al  是低八位
        mov ax,bx   ax = bx
        mov ah,0    ah = 0       
        mov al,0    al = o
        mov ax,0    ax = 0
                    add ax,bx      ax = ax+bx
                    add al,0       al = al+0
                    add ah,0       ah = ah+0   



    2.寻址 (8086 CPU 16位寻址)
        寄存器  ax ah al  ah 是ax的高8位   al是低8位
                        bx bh bl  同上

    3.确定物理地址方法
            1.主储存器地址空间
            2.显存地址空间
            3.各类ROM地址空间
        CPU访问内存单元时要给出内存的地址
        所有的内存单元构成的储存空间是一个一维的线性空间

# 12.30  内存地址的计算
    
     8086 CPU  20位地址总线宽度  16位数据总线宽的
            两个16位地址（段地址）（偏移地址）合成一个20位的物理地址
     
     地址加法器合成物理地址的方法
            物理地址 = 段地址 X 16 + 偏移地址

#  12.31 debug
    debug
        -R 查看寄存器 CS:IP 指向的内存地址 修改寄存器的值
            -r ax 回车 可以修改ax寄存器中的值 同理 CS:IP中的值也可以修改
        -D 查看以CS:IP为起始地址的128字节内存中的
            可指定起始地址
            -d 1000:0 
            -d 1000:9 从9开始到 1000:88 128字节
            -d 1000:0 9 查看0-9的内存中的数据
        -e 修改内存中的值 
            -e 1000:0 48 48对应的ascii码为H
            -e 1000:0 48 45 4c 4c 4f 对应 HELLO  
        -e b8 01 00 b9 02 00 01 c8   
        -u    对应的汇编指令可以用 -U 查看
            修改内存中的值 为机器码
            -r CS
            -r IP
            -t 单步执行
            
        ##总结    
            -R 查看，修改CPU中寄存器的内容
            -D 查看内存中的内容
            -E 修改内存中的内容
            -U 将内存中的内容解释为机器指令和对应的汇编指令
            -T 执行CS:IP指向的内存单元处的指令
            -A 以汇编指令的形式向内存中写入指令 
# DS 段寄存器
        注意传入与被传入的数据大小关系
        mov al,bx       a的低八位或高八位，无法接收bx,此时bx是字类型寄存器，而al是独立的字节型寄存器
        mov bx,al  
        mov ax,1000:0   1000:0作为低八位，送入al，而1000:1，作为高八位送入ah，此时ax=al+ah
        ////
        mov ax,1000     将1000H 送入ax寄存器
        mov ds,ax       将ax寄存器的值送入ds段寄存器中

                        [...]表示一个内存单元
        
        mov [0],ax      [0] 是偏移地址  自动取段寄存器中的段进行组合   
                        可以看成 mov 1000:0,ax 将ax寄存器中的值 送入1000:0内存地址
        --------------
        mov ax,1000     这里是用段寄存器，将内存地址中的值送到al寄存器中
        mov ds,ax
        mov al,[0]
# mov add sub 指令
    mov 寄存器，数据
    mov 寄存器，寄存器
    mov 寄存器，内存单元
    mov 内存单元，寄存器
    mov 段寄存器，寄存器
    mov 段寄存器，内存单元
    mov 内存单元，段寄存器    
            
        注意 数据不能直接到段寄存器，需要数据寄存器中转。 
                 数据也不能直接送到内存单元，需要寄存器中转
    ## start
    ax = 2000
        
        sub ax,1000  等同 ax = ax -1000
    
        ax = 1000

        add ax，1000 等同 ax = ax + 1000
        
        ax = 2000
    ## end
    
    add sub 可以对段寄存器进行运算吗 答案是不可以 
# 数据段
    
    字在内存中的存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。
    
    用mov指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。
    
    address表示一个偏移地址为address的内存单元。
    
    在内存和寄存器之间传送字形数据时，高地址单元和高8位寄存器，低地址单元和低8位寄存器相对应。

    mov，add sub 是具有两个操作对象的指令。jmp是具有一个操作对象的指令

    可以根据自己的推测，在debug中的实验指令的新格式。

# 栈
    SS:SP指向栈顶元素
    SS:段寄存器
    SP:偏移地址寄存器
    
    
    栈的特性           后进先出 
             先进后出

        PUSH 入栈
        POP  出栈
    我的基本理解 栈是一种数据结构，可以通过CPU应用在内存中

    mov ax,0123H
    push ax
    mov bx,2266H
    push bx
    mov cx,1122H
    push cx
    pop ax
    pop bx
    pop cx

    问题。 变成，将10000H~1000FH这段空间当作栈，初始状态栈是空的，将ax，bx，ds中的数据入栈
        mov ax,1000
        mov ss,ax
        mov sp,0010H            为什么特意强调栈是空的，因为栈不为空的话，sp的指向可能有问题

        push ax
        push bx
        push ds
    

    实验 ax bx 数据交换

        mov ax,1000
        mov ss,ax
        mov sp,0010
        mov ax,001a
        mov bx,001b
        push ax
        push bx
        pop ax
        pop bx     栈中数据后入先出 完成数据的 交换   ax = 001b bx = 001a
    
    这里需要注意的是 ss:sp sp的指向问题，push前 sp=sp—2 所以，如果想ss:sp指向10000H  ss = 1000 sp = 0002
    执行push时 CPU的两步操作是；先改变sp，后向ss:sp处传送。执行pop时，先读取ss:sp处的数据，后改变sp
# 第一个程序
    
        ds 正段地址寄存器
        ex 副段地址寄存器
        cx loop指令循环寄存器次数
        loop指令 
            assume cs:code   指定代码起始地址段为code
            code segment
                dw 0123H,0456H,0789H,0ABCH,0DEFH,0FEDH,0CBAH,0987H 在代码段中定义数据

            start: mov bx,0     这里的start 是为了告诉编译器，cs:ip的指向位置  不能和上面的数据冲突
                    mov ax,0
                    mov cx,8

                    s: add bx,cs:[ax]     ############ 这里需要注意，段前缀知识点  ##########
                        add ax,2
                        loop s  循环标记s  从s处开始循环，先cx减一，再跳转到s处执行，减一为0时不执行
                    
                    mov ax,4c00h
                    int 21h
            code end
            end start

# 由源程序到目标程序

        先编译后连接
        指令为 masm 和 link
        
# loop循环指令
        
        assume cs:code cs:ip 指向code区
        code segment
        mov ax，0ffffh
        mov ds，ax //将 ax中的内容赋值到ds段寄存器中
        mov bx，6

        mov al，[bx] //[bx]指向 ds：bx 也就是ffff6
        mov ah，0    // ax的高八位赋值为0
        
        mov dx，0 //累加器初始化
        mov cx，3 //cx寄存器的次数，是loop的循环次数，cx先减1再循环

        s：add dx，ax
        loop s

        mov ax，4c00h
        int 21h

        code ends
        end